# Listing of Parameters
# ---------------------
subsection FEM
  # Dimension of the problem
  set dimension      = 2

  # interpolation order pressure
  set pressure order = 1

  # Apply high order mapping everywhere
  set qmapping all   = false

  # interpolation order velocity
  set velocity order = 1
end


subsection analytical solution
  # Number of digits displayed when showing residuals
  set error precision = 3
end


subsection boundary conditions
  # Number of boundary conditions
  set number = 0


  subsection bc 0
    # Mesh id for boundary conditions
    set id                 = 00

    # Direction for periodic boundary condition
    set periodic_direction = 0

    # Mesh id for periodic face matching
    set periodic_id        = 0

    # Type of boundary conditoinChoices are <noslip|slip|function>.
    set type               = noslip


    subsection cor
      # X COR
      set x = 0

      # Y COR
      set y = 0

      # Z COR
      set z = 0
    end

    subsection u
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

    subsection v
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

    subsection w
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

  end

  subsection bc 1
    # Mesh id for boundary conditions
    set id                 = 01

    # Direction for periodic boundary condition
    set periodic_direction = 0

    # Mesh id for periodic face matching
    set periodic_id        = 0

    # Type of boundary conditoinChoices are <noslip|slip|function>.
    set type               = noslip


    subsection cor
      # X COR
      set x = 0

      # Y COR
      set y = 0

      # Z COR
      set z = 0
    end

    subsection u
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

    subsection v
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

    subsection w
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

  end

  subsection bc 2
    # Mesh id for boundary conditions
    set id                 = 02

    # Direction for periodic boundary condition
    set periodic_direction = 0

    # Mesh id for periodic face matching
    set periodic_id        = 0

    # Type of boundary conditoinChoices are <noslip|slip|function>.
    set type               = noslip


    subsection cor
      # X COR
      set x = 0

      # Y COR
      set y = 0

      # Z COR
      set z = 0
    end

    subsection u
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

    subsection v
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

    subsection w
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

  end

  subsection bc 3
    # Mesh id for boundary conditions
    set id                 = 03

    # Direction for periodic boundary condition
    set periodic_direction = 0

    # Mesh id for periodic face matching
    set periodic_id        = 0

    # Type of boundary conditoinChoices are <noslip|slip|function>.
    set type               = noslip


    subsection cor
      # X COR
      set x = 0

      # Y COR
      set y = 0

      # Z COR
      set z = 0
    end

    subsection u
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

    subsection v
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

    subsection w
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the muparser library at http://muparser.beltoforion.de/.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The names of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,y,t
    end

  end

end


subsection forces
  # Enable calculation of forces
  set calculate forces      = false

  # Enable calculation of torques
  set calculate torques     = false

  # Calculation frequency
  set calculation frequency = 1

  # Output frequency
  set display precision     = 4

  # File output force prefix
  set force name            = force

  # Output frequency
  set output frequency      = 1

  # Calculation frequency
  set output precision      = 10

  # File output force prefix
  set torque name           = torque

  # State whether from the non-linear solver should be printed Choices are
  # <quiet|verbose>.
  set verbosity             = quiet
end


subsection initial conditions
  # Type of initial conditionChoices are <none|L2projection|viscous|nodal>.
  set type      = none

  # viscosity for viscous initial conditions
  set viscosity = 1


  subsection uvwp
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the muparser
    # library at http://muparser.beltoforion.de/.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0; 0; 0 # default: 0; 0

    # The names of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated are `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,t
  end

end


subsection linear solver
  # amg aggregation threshold
  set amg aggregation threshold                 = 1e-14

  # amg number of cycles
  set amg n cycles                              = 1

  # amg preconditioner ilu smoother/coarsener absolute tolerance
  set amg preconditioner ilu absolute tolerance = 1e-12

  # amg preconditioner ilu smoother/coarsener fill
  set amg preconditioner ilu fill               = 1

  # amg preconditioner ilu smoother/coarsener relative tolerance
  set amg preconditioner ilu relative tolerance = 1.00

  # amg smoother overlap
  set amg smoother overlap                      = 1

  # amg smoother sweeps
  set amg smoother sweeps                       = 2

  # amg w cycling. If this is set to true, W cycling is used. Otherwise, V
  # cycling is used.
  set amg w cycles                              = false

  # Ilu preconditioner tolerance
  set ilu preconditioner absolute tolerance     = 1e-6

  # Ilu preconditioner fill
  set ilu preconditioner fill                   = 1

  # Ilu relative tolerance
  set ilu preconditioner relative tolerance     = 1.00

  # Maximum solver iterations
  set max iters                                 = 1000

  # The iterative solver for the linear system of equations. Choices are
  # <gmres|bicgstab|amg>. gmres is a GMRES iterative solver with ILU
  # preconditioning. bicgstab is a BICGSTAB iterative solver with ILU
  # preconditioning. amg is GMRES + AMG preconditioning with an ILU coarsener
  # and smoother. On coarse meshes, the gmres/bicgstab solver with ILU
  # preconditioning is more efficient. As the number of mesh elements
  # increase, the amg solver is the most efficient. Generally, at 1M elements,
  # the amg solver always outperforms the gmres or bicgstab
  set method                                    = gmres

  # Linear solver minimum residual
  set minimum residual                          = 1e-8

  # Linear solver residual
  set relative residual                         = 1e-3

  # Number of digits used when outputing the residual in the terminal
  set residual precision                        = 6

  # State whether output from solver runs should be printed. Choices are
  # <quiet|verbose>.
  set verbosity                                 = verbose
end


subsection mesh
  # GMSH file name
  set file name          = none

  # Initial refinement of primitive mesh
  set initial refinement = 0

  # Type of mesh Choices are <gmsh|primitive>.
  set type               = gmsh
end


subsection mesh adaptation
  # Fraction of coarsened elements
  set fraction coarsening  = 0.05

  # Fraction of refined elements
  set fraction refinement  = 0.1

  # How the fraction of refinement/coarsening are interepretedChoices are
  # <number|fraction>.
  set fraction type        = number

  # Frequency of the mesh refinement
  set frequency            = 1

  # Maximum number of elements
  set max number elements  = 100000000

  # Maximum refinement level
  set max refinement level = 10

  # Minimum refinement level
  set min refinement level = 1

  # Type of mesh adaptationChoices are <none|uniform|kelly>.
  set type                 = none

  # Variable for kelly estimationChoices are <velocity|pressure>.
  set variable             = velocity
end


subsection non-linear solver
  # Maximum number of Newton Iterations
  set max iterations     = 10

  # Number of digits displayed when showing residuals
  set residual precision = 4

  # Newton solver tolerance
  set tolerance          = 1e-6

  # State whether from the non-linear solver should be printed Choices are
  # <quiet|verbose>.
  set verbosity          = verbose
end


subsection physical properties
  # Kinematic viscosity
  set kinematic viscosity = 1
end


subsection restart
  # Enable checkpointing
  set checkpoint = false

  # Prefix for the filename of checkpoints
  set filename   = restart

  # Frequency for checkpointing
  set frequency  = 1

  # Frequency for checkpointing
  set restart    = false
end


subsection simulation control
  # Adaptative time-stepping <true|false>
  set adapt                = false

  # Maximum CFL value
  set max cfl              = 1

  # The kind of solver for the linear system. Choices are
  # <steady|backward|bdf2|bdf3>.
  set method               = steady

  # Number of mesh adaptation (for steady simulations)
  set number mesh adapt    = 0

  # Output frequency
  set output frequency     = 1

  # File output prefix
  set output name          = out

  # File output prefix
  set output path          = ./

  # Scaling factor used in the iterations necessary to start-up the BDF
  # schemes.
  set startup time scaling = 0.1

  # Subdivision of mesh cell in postprocessing
  set subdivision          = 1

  # Time step value
  set time end             = 1

  # Time step value
  set time step            = 1.
end


subsection test
  # Enable testing mode of a solver
  set enable = false
end


subsection timer
  # Clock monitoring methods Choices are <none|iteration|end>.
  set type = none
end


